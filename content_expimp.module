<?php
/**
 * @file
 * Create (manually or scheduled) and restore backups of your Drupal MySQL
 * database with an option to exclude table data (e.g. cache_*)
 */

include_once 'includes/mysqldumpdiff.class.php';

/* Drupal Hooks */

/**
 * Implements hook_menu().
 */
function content_expimp_menu() {
  $items = array();
  $items['admin/content/content_expimp'] = array(
    'title' => 'Content exPimp',
    'description' => 'Backup/export data with an optional diff feature',
    'page callback' => 'content_expimp_export',
    'access arguments' => array('perform content export'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/content/content_expimp/export'] = array(
    'title' => 'Content exPimp',
    'description' => 'Backup/export data with an optional diff feature',
    'page callback' => 'content_expimp_export',
    'access arguments' => array('perform content export'),
    'weight' => 0,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/content/content_expimp/config'] = array(
    'title' => 'Administer',
    'description' => 'Administer configurations for data export.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('content_expimp_admin_settings'),
    'access arguments' => array('administer content export'),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function content_expimp_permission() {
  return array(
    'perform content export' => array(
      'title' => t('Perform Content Export'),
      'description' => t('Execute data exporting.'),
      'restrict access' => TRUE,
    ),
    'administer content export' => array(
      'title' => t('Administer Content Export'),
      'description' => t('Configure tables map for data exporting.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_form().
 */
function content_expimp_export($form, &$form_state) {

  if (isset($form_state['result'])) {
    $form['sql'] = array(
    '#type' => 'textarea',
    '#title' => t('Diff SQL:'),
    '#rows' => $form_state['rows'],
    '#default_value' => $form_state['result'],
    );
  }
  else {
    $form['export'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Select what to export'),
      '#options' => array(
        'all' => t('Export all'),
        'user' => t('Export users data'),
        'node' => t('Export nodes data'),
        'shared' => t('Export shared data'),
        'taxonomy_term' => t('Export taxonomy data'),
        'block' => t('Export blocks data'),
        'locale' => t('Export locale data'),
      ),
    );
    $form['diff'] = array(
      '#type' => 'checkbox',
      '#title' => t('Generate diff export'),
      '#description' => 'Export only changes from previous export.',
    );
  
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Export'),
    );

    $form['#validate'][] = 'content_expimp_export_validate';
    $form['#submit'][] = 'content_expimp_export_submit';
  }

  return $form;
}


/**
 * Validation function for admin settings.
 */
function content_expimp_export_validate($form, &$form_state) {
  $valid = FALSE;
  foreach ($form_state['values']['export'] as $key=>$value) {
  	 if ($value !== 0) {
  	 	$valid = TRUE;
  	 }
  }
  if ($valid) {
    return TRUE;
  }
  else {
    form_set_error('export', t('You have to select at least one type of content to export.'));
    return FALSE;
  }
}

/**
 * Submit handler for export form.
 */
function content_expimp_export_submit($form, &$form_state) {
  //require (dirname(__FILE__).'/includes/mysqldumpdiff.class.php');

  $export_what = $form_state['values']['export'];
  $exported_content = _export_selected_content($export_what);

  $generate_diff = $form_state['values']['diff'];
  if ($generate_diff) {
  	 $obj = new MySQLdumpDiff();
    $obj->File1 = 'bckp_tecnonet_usersdata.mysql';
    $obj->File2 = $exported_content;
    $obj->File3 = 'diff_usersdata.mysql';
    $obj->Options = array(2,2); // 1= with statistics per table , 2= without / 1= with CREATE statements , 2= without
    $obj->Export = 'print'; // or 'file'
    $obj->ProcessFiles();
  }
  else {
    $output = "";
    $rows = 0;
    foreach ($exported_content as $key=>$value) {
      $output .= $value."\n";
      $rows++;
	 }
  }
  
  $form_state['rows'] = $rows;
  $form_state['result'] = $output;
  $form_state['rebuild'] = TRUE;
}

/**
 * Process export.
 */
function _export_selected_content($selection) {
  require (dirname(__FILE__).'/includes/content.db.map.inc');

  $tables_selected = array();
  foreach ($selection as $key=>$value) {
  	 if ($value !== 0) {
      foreach ($chosen_tables[$key] as $item) {
        $tables_selected = array_merge($tables_selected, $item);
      }
    }
  }
  $export_sql = array();
  foreach ($tables_selected as $table) {
    $export_sql = array_merge($export_sql, _dump_table_data_sql_to_array($table));
  }

  return $export_sql;
}

  /**
   *  Get the sql to insert the data for a given table
   */
function _dump_table_data_sql_to_array($table) {
  $tobe_file = array();
  $rows_per_line = 30;
  $bytes_per_line = 2000;
  
  $lines = 0;
  $data = db_select($table, 't')
    ->fields('t', array())
    ->execute()
    ->fetchAll(PDO::FETCH_ASSOC); 
  $rows = $bytes = 0;

  // Escape backslashes, PHP code, special chars
  $search = array('\\', "'", "\x00", "\x0a", "\x0d", "\x1a");
  $replace = array('\\\\', "''", '\0', '\n', '\r', '\Z');
  
  $line = array();
  foreach ($data as $row) {
    $tobe_line = "";
    // DB Escape the values.
    $items = array();
    foreach ($row as $key => $value) {
      $items[] = is_null($value) ? "null" : "'". str_replace($search, $replace, $value) ."'";
    }

    // If there is a row to be added.
    if ($items) {
      // Start a new line if we need to.
      if ($rows == 0) {
        $tobe_line .= "INSERT INTO `". $table ."` VALUES ";
        $bytes = $rows = 0;
      }
      // Otherwise add a comma to end the previous entry.
      else {
        $tobe_line .= ",";
      }

      // Write the data itself.
      $sql = implode(',', $items);
      $tobe_line .= '('. $sql .')';
      $bytes += strlen($sql);
      $rows++;

      // Finish the last line if we've added enough items
      if ($rows >= $rows_per_line || $bytes >= $bytes_per_line) {
        $tobe_file[] = $tobe_line.";\n";
        $lines++;
        $bytes = $rows = 0;
      }
    }
  }
  // Finish any unfinished insert statements.
  if ($rows > 0) {
    $tobe_file[] = $tobe_line.";\n";
    $lines++;
  }

  return $tobe_file;
}

/**
 * Implements hook_theme().
function content_expimp_theme() {
  return array(
    'content_expimp_display' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Builds final export displaying.
function theme_content_expimp_display($variables) {
  $element = $variables['form'];
  $output = '' . t('This is the value that was submitted') . '';
  $output .= '' . $element['#value'] . '';

  return $output;
}
 */

/**
 * Implements hook_form().
 */
function content_expimp_admin_settings() {
  $alltables = _get_all_database_tables();
  $leftables = _get_left_tables($alltables);
  
  $form['other_tables'] = array(
    '#type' => 'fieldset',
    '#title' => t('Tables left'),
    '#prefix' => '<strong>Select lero lero.</strong>',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['other_tables']['options'] = array(
    '#type' => 'checkboxes',
    '#options' => $leftables,
  );
  $form['term_tables'] = array(
    '#type' => 'fieldset',
    '#title' => t('Term tables'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['term_tables']['options'] = array(
    '#type' => 'checkboxes',
    '#options' => _get_entity_bundle_options('taxonomy_term', 'all'),
    '#default_value' => _get_selected_options('taxonomy_term', 'all')
  );
  $contfields = taxonomy_get_vocabularies();
  foreach ($contfields as $item) {
    $form['term_tables'][$item->machine_name] = array(
      '#type' => 'fieldset',
      '#title' => t($item->name.' tables'),
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,
    );
    $form['term_tables'][$item->machine_name]['options'] = array(
      '#type' => 'checkboxes',
      '#options' => _get_entity_bundle_options('taxonomy_term', $item->machine_name),
      '#default_value' => _get_selected_options('taxonomy_term', $item->machine_name),
    );
  }
  $form['node_tables'] = array(
    '#type' => 'fieldset',
    '#title' => t('Node tables'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['node_tables']['options'] = array(
    '#type' => 'checkboxes',
    '#options' => _get_entity_bundle_options('node', 'all'),
    '#default_value' => _get_selected_options('node', 'all'),
  );
  $contfields = node_type_get_types();
  foreach ($contfields as $key=>$value) {
    $form['node_tables'][$key] = array(
      '#type' => 'fieldset',
      '#title' => t($key.' tables'),
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,
    );
    $form['node_tables'][$key]['options'] = array(
      '#type' => 'checkboxes',
      '#options' => _get_entity_bundle_options('node', $key),
      '#default_value' => _get_selected_options('node', $key),
    );
  }
  
  $contfields = array('shared', 'user', 'block', 'locale');
  foreach ($contfields as $item) {
    $form[$item.'_tables'] = array(
      '#type' => 'fieldset',
      '#title' => t($item.' tables'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    $form[$item.'_tables']['options'] = array(
      '#type' => 'checkboxes',
      '#options' => _get_entity_bundle_options($item, 'all'),
      '#default_value' => _get_selected_options($item, 'all'),
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save configurations'),
  );

  //$form['#validate'][] = 'content_expimp_admin_settings_validate';
  $form['#submit'][] = 'content_expimp_admin_settings_submit';

  return $form;
}

/**
 * Validation function for admin settings.
 */
function content_expimp_admin_settings_validate($form, &$form_state) {
}

/**
 * Submit handler for admin form.
 */
function content_expimp_admin_settings_submit($form, &$form_state) {
  $export_what = $form_state['values']['content_expimp_admin_settings'];

  if ($reset_what === 'reset_all' || $reset_what === 'reset_files') {
    // Delete the files.
    _drupal_reset_delete_files();
  }

  if ($reset_what === 'reset_all' || $reset_what === 'reset_database') {
    // Drop the database
    _drupal_reset_drop_database();
  }

  drupal_set_message('Actions will come soon.');
}

/**
 * Searches default database and returns all of its tables().
 */
function _get_all_database_tables() {
  global $databases;
  $chosen_tables = db_find_tables($databases['default']['default']['prefix'] . '%');
  foreach ($chosen_tables as $key=>$value) {
    $alltables[$key] = $value;
  }
  return $alltables;
}

/**
 * Finds all tables not selected for exporting.
 */
function _get_left_tables($allthem) {
  require (dirname(__FILE__).'/includes/content.db.map.inc');
  $leftarr = array();
  foreach ($allthem as $item) {
    $leftout = TRUE;
    foreach ($chosen_tables as $entity) {
      foreach ($entity as $selected_tables) {
        if (in_array($item, $selected_tables)) {
          $leftout = FALSE;
          break;
        }
      }
      if (!$leftout) {
        break;
      }
    }
    if ($leftout) {
      $leftarr[$item] = $item;
    }
  }
  return $leftarr;
}

/**
 * Searches default database for existing content types.
 */
function _get_entity_bundle_options($entity, $bundle = 'all') {
  require (dirname(__FILE__).'/includes/content.db.map.inc');
  $options = array();
  if ($bundle != 'all') {
    $instances = field_info_instances($entity, $bundle);
    if ($entity == 'node') {
      foreach ($instances as $key=>$value) {
        $options['field_data_'.$key] = 'field_data_'.$key;
        $options['field_revision_'.$key] = 'field_revision_'.$key;
      }
    }
    elseif ($entity == 'taxonomy_term') {
      foreach ($instances as $key=>$value) {
        $options['field_data_'.$value['field_name']] = 'field_data_'.$value['field_name'];
        $options['field_revision_'.$value['field_name']] = 'field_revision_'.$value['field_name'];
      }
    }
  }
  else {
    $instances = $chosen_tables[$entity]['all'];
    foreach ($instances as $key=>$value) {
      $options[$value] = $value;
    }
  }
  return $options;
}

/**
 * Searches default database and returns all of its tables().
 */
function _get_selected_options($entity, $bundle = 'all') {
  require (dirname(__FILE__).'/includes/content.db.map.inc');
  if ($entity == 'all') {
    $targetarr = array_merge($chosen_tables['users'], $chosen_tables['nodes'], $chosen_tables['taxonomy_term'], $chosen_tables['locale'], $chosen_tables['shared']);
  }
  else {
/**
  	 if ($entity == 'taxonomy_term') {
  	   $value = $value['field_name'];
  	 }
*/
    $targetarr = $chosen_tables[$entity][$bundle];
  }
  $options = array();
  foreach ($targetarr as $key=>$value) {
    $options[] = $value;
  }
  return $options;
}
